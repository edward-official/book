1. Signal Terminology
2. Sending Signals
3. Receiving Signals
4. Blocking and Unblocking Signals
5. Writing Signal Handlers
6. Synchronizing Flows to Avoid Nasty Concurrency Bugs
7. Explicitly Waiting for Signals

## Opening
1. 리눅스 시그널이라는 고수준의 예외 흐름을 공부한다.
2. 시그널이란 어떤 이벤트를 프로세스에게 알리는 메세지이다.

## Signal Terminology
1. 시그널 보내기
2. 시그널 받기
3. 펜딩/블락 시그널
4. 펜딩/블락 비트 벡터
5. 시그널 핸들러

## Sending Signals
1. 프로세스 그룹
	1. 기본적으로 부모와 자식은 같은 그룹에 속한다.
	2. 하지만 setpgid() 함수를 통해서 특정 프로세스의 그룹 변경을 할 수 있다.
2. 시그널을 보내는 방법
	1. /bin/kill
	2. keyboard (UNIX Shell)
		1. 유닉스 셸은 job 개념을 사용한다.
		2. 이는 단일 명령줄에 있는 프로세스의 집합이다.
		3. 어느 한 시점에 포어그라운드 작업은 적어도 1개 이상, 백그라운드 작업은 적어도 0개 이상이 존재한다.
		4. 셸이라는 것도 하나의 프로세스이다.
		5. 그 셸을 통해서 실행되는 프로세스는 그 하위로 들어간다.
		6. 의문점: 셸의 내부에서 실행되는 프로세스는 셸과 부모-자식 관계는 아니겠지?
	3. kill()
	4. alarm()

## Receiving Signals
1. 커널 모드에서 사용자 모드로 전환할 때(예를 들어서 시스템 콜이 끝나거나, 컨텍스트 스위치 후) 커널은 언블럭 시그널 중 보류 중인 시그널 집합을 검사한다.
2. 만약 그 집합이 비어있다면 커널은 해당 프로세스 p의 논리적 제어 흐름 내 다음 명령어로 제어를 넘겨준다. 그렇지 않다면, 커널은 그 중 일부의 시그널을 선택하고 