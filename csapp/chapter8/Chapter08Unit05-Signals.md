1. Signal Terminology
2. Sending Signals
3. Receiving Signals
4. Blocking and Unblocking Signals
5. Writing Signal Handlers
6. Synchronizing Flows to Avoid Nasty Concurrency Bugs
7. Explicitly Waiting for Signals

## Opening
1. 리눅스 시그널이라는 고수준의 예외 흐름을 공부한다.
2. 시그널이란 어떤 이벤트를 프로세스에게 알리는 메세지이다.

## Signal Terminology
1. 시그널 보내기
2. 시그널 받기
3. 펜딩/블락 시그널
4. 펜딩/블락 비트 벡터
5. 시그널 핸들러

## Sending Signals
1. 프로세스 그룹
	1. 기본적으로 부모와 자식은 같은 그룹에 속한다.
	2. 하지만 setpgid() 함수를 통해서 특정 프로세스의 그룹 변경을 할 수 있다.
2. 시그널을 보내는 방법
	1. /bin/kill
	2. keyboard (UNIX Shell)
		1. 유닉스 셸은 job 개념을 사용한다.
		2. 이는 단일 명령줄에 있는 프로세스의 집합이다.
		3. 어느 한 시점에 포어그라운드 작업은 적어도 1개 이상, 백그라운드 작업은 적어도 0개 이상이 존재한다.
		4. 셸이라는 것도 하나의 프로세스이다.
		5. 그 셸을 통해서 실행되는 프로세스는 그 하위로 들어간다.
			1. 셸의 내부에서 실행되는 프로세스는 셸과 부모-자식 관계는 아니겠지??
	3. kill()
	4. alarm()

## Receiving Signals
1. 시그널 수신 절차
	1. 커널 모드에서 사용자 모드로 전환할 때(예를 들어서 시스템 콜이 끝나거나, 컨텍스트 스위치 후) 커널은 언블럭 시그널 중 보류 중인 시그널 집합을 검사한다.
	2. 만약 그 집합이 비어있다면 커널은 해당 프로세스 p의 논리적 제어 흐름 내 다음 명령어로 제어를 넘겨준다. 그렇지 않다면, 커널은 그 중 일부의 시그널을 선택하고 프로세스 p가 그 시그널들을 수신하도록 강제하고 프로세스가 특정 동작(아마 시그널 핸들러)를 수행하고 프로세스 p의 논리적 제어 흐름 내 다음 명령어로 돌아간다.
		1. 아니 왜 일부만이야?? 전부 다 해야하는거 아닌가??
2. 각 시그널의 기본 동작 (다음 중 하나)
	1. 프로세스를 종료한다.
	2. 프로세스를 종료하고 코어 덤프를 남긴다.
		1. 코어 덤프가 뭐야??
	3. 프로세스를 일시중지하고 재개 시그널이 올 때까지 기다린다.
	4. 시그널을 무시한다.
3. 특정 시그널의 기본 동작을 signal() 함수를 통해 변경할 수 있다. (스탑, 킬 시그널 제외)
	1. signal() 함수의 3가지 활용법
		1. 시그널 핸들러(사용자 정의 함수)를 연결
		2. 디폴드 메크로 연결
		3. 무시 메크로 연결
	2. 시그널 포착: 핸들러가 호출되는 것
	3. 시그널 처리: 핸들러가 실행되는 것
	4. 핸들러가 종료되면 제어 흐름은 시그널이 인터럽트했던 지점의 다음 명령어로 넘어간다.
	5. 시그널 핸들러는 다른 시그널 핸들러에 의해 interrupt될 수 있다.

## Blocking and Unblocking Signals
1. 시그널 차단의 2가지 매커니즘
	1. 암묵적(implicit)
		1. 커널은 현재 핸들러가 처리중인 시그널과 동일한 시그널을 자동으로 차단한다.
		2. 동일한 시그널은 보류 상태가 될 수는 있지만 응용 프로그램으로 전달될 수는 없다.
	2. 명시적(explicit)
		1. sigprocmask() 메서드를 이용해서 특정 시그널을 명시적으로 차단/해제할 수 있다.

## Writing Signal Handlers
1. 시그널 핸들링이 까다로운 이유
	1. 시그널 핸들러는 메인 프로그램과 동시에 실행되며, 같은 전역 변수를 공유한다. 이 때문에 핸들러는 메인 프로그램 또는 다른 핸들러의 동작을 방해(interrupt)할 수 있다.
	2. 시그널이 언제 어떤 순서로 도착하는 지에 관한 규칙이 직관적이지 않다.
	3. 시스템마다 시그널 처리 방식이 다르다.
	4. ?? 어디선가 핸들러는 메모리에만 쓸 수 있고 캐시나 레지스터에는 값을 수정할 수 없다고 들었는데 사실인가??
2. 보수적인 시그널 핸들링 가이드라인
	1. 핸들러를 단순하게 유지하고 플러그 처리는 메인 프로그램의 주기적 검사 루프에서 실행하도록 해라.
	2. 핸들러에서 signal-safe한 함수만 호출해라.
		1. signal-safe 함수의 특성
			1. 재진입 가능한 특성
			2. 인터럽트 되지 않는 설계
		2. 안전한 Sio(Safe I/O) 패키지 제공
	3. errno 저장 및 복원
		1. 리눅스 함수들은 에러 상황에서 errno를 설정한다
		2. ?? errno가 뭔데??
	4. 공유 자료 접근 시 모든 시그널을 임시적으로 차단해라.
	5. 전역 변수를 volatile로 선언하라.
		1. ?? 여기서 핸들러는 무조건 메모리 값만 수정이 가능하다고 들었던 것 같은데 과연 사실일까??
	6. 플래그 선언 시 sig_atomic_t를 사용해라
		1. 읽기/쓰기 연산이 단일 명령어로 수행되어서 인터럽트 되지 않는다.
		2. 즉, 기계 수준으로 분해했을 때 단일 명령어로만 구성되는 명령어만 가능한 듯 하다. (??)