지금까지는 가상 메모리가 **DRAM을 사용하여 일반적으로 더 큰 가상 주소 공간으로부터 페이지를 캐싱하는 메커니즘**을 제공하는 방식을 살펴보았습니다.
흥미롭게도 초기 시스템 중 일부는 **가상 주소 공간이 실제 물리 메모리보다 작았던** 경우도 있었습니다.
그럼에도 불구하고 가상 메모리는 여전히 매우 유용한 메커니즘이었는데, 그 이유는 메모리 관리가 훨씬 단순해지고 **자연스러운 메모리 보호 방식**을 제공했기 때문입니다.

지금까지 우리는 하나의 가상 주소 공간이 하나의 물리 주소 공간에 매핑되는 **단일 페이지 테이블**을 가정했습니다.
하지만 실제로 **운영체제는 각 프로세스마다 별도의 페이지 테이블과 가상 주소 공간을 제공합니다.**
또한, 여러 가상 페이지가 동일한 물리 페이지를 **공유(shared)** 할 수도 있습니다.

#### 용어 정리
- 물리 주소 공간: 메인 메모리
- 가상 주소 공간: 디스크
- Demand Paging: 프로그램 전체를 메모리에 올리는 대신 당장 필요한 페이지만 메모리에 올려 사용하는 가상 메모리 관리 방식

## 가상 메모리가 가져오는 4가지 효과
#### 1. 링크 과정을 단순화 (Simplifying Linking)

각 프로세스가 고유한 주소 공간을 가지므로, 코드나 데이터가 물리 메모리의 어디에 실제로 존재하는지에 관계없이 **모든 프로세스는 동일한 형식의 메모리 이미지(memory image)** 를 사용할 수 있습니다.

예를 들어, 64비트 리눅스 시스템에서는 모든 프로세스의 코드 세그먼트가 항상 **가상 주소 0x400000** 에서 시작합니다.
데이터 세그먼트는 코드 세그먼트 다음의 적절한 정렬 지점에서 시작하고, 스택은 사용자 프로세스 주소 공간의 가장 높은 부분에서 **아래쪽으로 성장(grows downward)** 합니다.

이런 통일성 덕분에 **링커(linker)** 의 설계와 구현이 훨씬 단순해집니다.
링커는 코드와 데이터의 실제 물리적 위치를 신경 쓰지 않고 완전한 실행 파일을 만들 수 있습니다.

#### 2. 로딩 과정을 단순화 (Simplifying Loading)

가상 메모리는 **실행 파일(executable)** 과 **공유 객체(shared object)** 를 메모리에 쉽게 불러올 수 있도록 해줍니다.
예를 들어, 새 프로세스를 만들 때 리눅스 로더는 `.text` 와 `.data` 섹션에 대한 **가상 페이지를 할당하고**, 이를 “아직 캐싱되지 않음(invalid)” 상태로 표시합니다.

그다음 각 PTE(Page Table Entry)를 **해당 파일의 적절한 디스크 위치**로 연결합니다.
흥미로운 점은 **로더가 실제 데이터를 디스크에서 복사하지 않는다는 것**입니다.
대신, 처음 해당 가상 페이지가 참조될 때 가상 메모리 시스템이 자동으로 디스크에서 데이터를 읽어옵니다. (이는 “on-demand paging”으로 불립니다.)

이렇게 가상 페이지 집합을 디스크 파일의 임의의 위치에 매핑하는 방식을 **메모리 매핑(memory mapping)** 이라고 부릅니다.
리눅스는 `mmap` 시스템 콜을 제공하여 응용 프로그램이 스스로 이러한 메모리 매핑을 수행할 수 있도록 합니다.

#### 3. 코드 및 데이터 공유의 단순화 (Simplifying Sharing)

분리된 주소 공간은 **프로세스 간 메모리 공유를 안전하게 관리할 수 있는 통합된 메커니즘**을 제공합니다.
일반적으로 각 프로세스는 자신만의 코드, 데이터, 힙, 스택 영역을 가지며 다른 프로세스와 공유되지 않습니다.
운영체제는 이러한 영역들이 서로 다른 물리 페이지에 매핑되도록 페이지 테이블을 설정합니다.

하지만 경우에 따라 **프로세스 간 코드 또는 데이터 공유가 필요할 때**가 있습니다.
예를 들어:

* 모든 프로세스는 동일한 **커널 코드**를 호출해야 합니다.
* 모든 C 프로그램은 표준 C 라이브러리의 `printf` 같은 함수를 사용합니다.

이때 운영체제는 여러 프로세스가 같은 물리 페이지를 공유하도록 서로 다른 프로세스의 가상 페이지를 **같은 물리 페이지에 매핑**할 수 있습니다.

#### 4. 메모리 할당의 단순화 (Simplifying Memory Allocation)

가상 메모리는 사용자 프로세스가 새로운 메모리를 요청할 때 추가 메모리를 쉽게 할당할 수 있는 메커니즘을 제공합니다.

예를 들어, 프로그램이 `malloc` 호출을 통해 새로운 힙 공간을 요청하면, 운영체제는 연속된 **k개의 가상 페이지**를 할당하고, 이를 **임의의 k개의 물리 페이지**에 매핑합니다.

이 덕분에 운영체제는 실제로 **연속된 물리 메모리 공간을 찾을 필요가 없습니다.**
페이지 단위 매핑 덕분에 논리적으로는 연속된 메모리처럼 보이지만 물리적으로는 흩어져 있을 수 있습니다.
