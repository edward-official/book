리눅스에서 파일(file)은 m개의 바이트로 이루어진 순서열이다:

```
B0, B1, … , Bk, … , Bm−1
```

모든 I/O 장치(네트워크, 디스크, 터미널 등)는 파일로 모델링되며, 모든 입출력은 파일을 읽거나 쓰는 형태로 수행된다.
이런 통일된 방식 덕분에 리눅스 커널은 Unix I/O라는 단순하고 일관된 인터페이스를 제공한다.

##### 파일 열기 (Opening files)

프로세스가 파일에 접근하려면 커널에 요청하여 파일을 열어야(open) 한다.
커널은 이때 ==디스크립터(descriptor)==라는 정수 값을 반환한다.
이 디스크립터는 이후 해당 파일에 대한 모든 I/O 연산에서 사용된다.

리눅스 셸에서 실행된 모든 프로세스는 기본적으로 세 개의 열린 파일을 가진다:

* 표준 입력 (`descriptor 0`)
* 표준 출력 (`descriptor 1`)
* 표준 오류 (`descriptor 2`)

이 상수들은 `<unistd.h>`에 다음과 같이 정의되어 있다:
`STDIN_FILENO`, `STDOUT_FILENO`, `STDERR_FILENO`

##### 파일 위치 변경 (Changing the current file position)

커널은 파일마다 ==파일 위치(file position)== `k`를 유지한다.
이는 파일 시작부터 현재 위치까지의 바이트 오프셋이다.
프로그램은 ==`seek`== 연산으로 파일 위치를 명시적으로 변경할 수 있다.

##### 읽기와 쓰기 (Reading and writing files)

* 읽기(read):
  n > 0 바이트를 파일에서 메모리로 복사하고, 현재 파일 위치를 `k + n`으로 증가시킨다.
  `k ≥ m`이면 파일 끝(EOF)에 도달한다.

* 쓰기(write):
  n > 0 바이트를 메모리에서 파일로 복사하고, 파일 위치를 `k + n`으로 증가시킨다.

##### 파일 닫기 (Closing files)

파일 접근이 끝나면 `close`를 호출해 닫는다.
커널은 ==파일 관련 자료구조를 해제==하고, ==디스크립터를 재사용 가능 상태==로 만든다.
==프로세스가 종료되면 커널은 자동으로 모든 열린 파일을 닫고 자원을 해제한다.==

