응용 프로그램은 `read`와 `write` 함수를 호출하여 입력과 출력을 수행한다.

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t n);
  // 성공 시 읽은 바이트 수 반환, EOF 시 0, 오류 시 -1 반환

ssize_t write(int fd, const void *buf, size_t n);
  // 성공 시 쓴 바이트 수 반환, 오류 시 -1 반환
```

`read` 함수는 파일 디스크립터 `fd`의 현재 위치로부터 최대 `n`바이트를 읽어 `buf`가 가리키는 메모리 위치로 복사한다.
반환값이 -1이면 오류, 0이면 EOF(파일의 끝), 그 외의 경우에는 실제로 전송된 바이트 수를 나타낸다.

`write` 함수는 메모리의 `buf`로부터 최대 `n`바이트를 파일로 복사한다.


##### `ssize_t`와 `size_t`의 차이

`read` 함수는 `size_t`형 인자를 받고 `ssize_t`형 값을 반환한다.
두 타입의 차이는 다음과 같다:

* `size_t`: 부호 없는 정수 (`unsigned long`)
* `ssize_t`: 부호 있는 정수 (`long`)

`read`가 오류 시 -1을 반환해야 하므로 부호 있는 타입이 필요하다.
이 때문에 `ssize_t`는 읽을 수 있는 최대 크기가 절반으로 줄어들지만 에러 표현이 가능하다는 장점이 있다.


##### 예제: 표준 입력을 표준 출력으로 복사

```c
#include "csapp.h"

int main(void) {
  char c;
  while (Read(STDIN_FILENO, &c, 1) != 0)
    Write(STDOUT_FILENO, &c, 1);
  exit(0);
}
```

이 프로그램은 표준 입력(`stdin`)에서 한 번에 1바이트씩 읽어 표준 출력(`stdout`)으로 그대로 복사한다.


##### Short Count (짧은 읽기/쓰기)

때때로 `read`나 `write`는 요청한 바이트보다 더 적은 수의 바이트를 전송한다.
이러한 short count는 오류가 아니며, 여러 이유로 발생할 수 있다.

1. EOF 도달 (End of File)
   예를 들어 파일 끝에 20바이트만 남았는데 50바이트를 요청하면, `read`는 20바이트만 읽고 그 다음에는 0(EOF)을 반환한다.

2. 터미널 입력
   터미널(키보드)에서 입력을 읽을 때는 사용자가 한 줄 입력할 때마다 그 라인 전체가 한 번에 읽힌다.

3. 네트워크 소켓
   네트워크 지연이나 내부 버퍼 제한 때문에 `read`와 `write`가 요청한 크기보다 작은 short count를 반환할 수 있다.


##### 실무에서의 주의점

디스크 파일에서는 short count가 거의 없지만,
네트워크 프로그래밍(Web 서버 등)에서는 매우 흔하다.
따라서 안정적인 프로그램을 작성하려면,
`read` 또는 `write`를 반복 호출해 모든 요청한 바이트가 전송될 때까지 처리해야 한다.


