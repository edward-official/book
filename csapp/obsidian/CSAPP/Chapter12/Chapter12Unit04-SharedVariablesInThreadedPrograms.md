프로그래머의 관점에서 보면, 스레드의 가장 매력적인 특징 중 하나는 여러 스레드가 동일한 프로그램 변수를 쉽게 공유할 수 있다는 점이다.
==하지만 이러한 공유는 다소 까다로울 수 있다.== 올바른 스레드 기반 프로그램을 작성하려면,
“공유”의 의미가 정확히 무엇이며 그것이 어떻게 작동하는지를 명확히 이해해야 한다.

C 프로그램에서 어떤 변수가 공유되는지를 이해하기 위해서는 다음과 같은 ==세 가지 기본적인 질문==을 생각해야 한다.

1. 스레드의 기본 메모리 모델(memory model) 은 무엇인가?
2. 이 모델에 따라 각 변수의 인스턴스(instance)는 메모리에 어떻게 매핑되는가?
3. 그리고 각각의 변수 인스턴스는 몇 개의 스레드에 의해 참조되는가?


## 예제 프로그램

![[Screenshot 2025-11-06 at 22.47.38.png]]

이 프로그램은 간단하지만, 스레드 간 변수 공유의 다양한 측면을 이해하는 데 매우 유용하다.
메인 스레드는 두 개의 피어 스레드를 생성하고, 각 스레드에 고유한 ID를 전달한다.
각 피어 스레드는 자신의 ID와 함께 메시지(`ptr[myid]`)를 출력하며, 호출 횟수를 나타내는 `cnt`를 출력한다.


## 12.4.1 스레드 메모리 모델 (Threads Memory Model)

여러 스레드는 하나의 프로세스 컨텍스트(context) 내에서 실행된다.
각 스레드는 고유한 ==스레드 문맥(thread context)== 을 가지며, 그 안에는 다음이 포함된다.

* 스레드 ID (TID)
* 스택(stack)과 스택 포인터(stack pointer)
* 프로그램 카운터(program counter)
* 조건 코드(condition codes)
* 범용 레지스터(general-purpose registers)

==이 외의 프로세스 자원(코드, 데이터, 힙, 공유 라이브러리, 열린 파일 등)은 모든 스레드가 공유한다.==

운영 측면에서 보면, 한 스레드가 다른 스레드의 레지스터 값을 읽거나 쓰는 것은 불가능하다.
하지만 가상 메모리 내의 어떤 위치든 접근할 수 있다. ==(아니 이게 말이돼?? 컨텍스트 스위칭에서 잠시 커널 영역으로 밀려난 스레드 컨텍스트에는 접근을 못할거 아니야)==
즉, 한 스레드가 공유 가상 메모리 내의 값을 변경하면, 다른 모든 스레드가 그 변경을 볼 수 있다.

따라서 레지스터는 절대 공유되지 않지만, 가상 메모리는 항상 공유된다.


스택의 경우는 다소 복잡하다.
각 스레드는 고유한 스택을 가지며, 이 스택은 가상 주소 공간 내에서 따로 구분되어 있다.
일반적으로 스레드는 자신의 스택만 접근할 수 있지만, 다른 스레드의 스택 포인터 주소를 얻어내면 그 스택의 데이터를 읽거나 쓸 수도 있다.
==즉, “보통은” 스택이 분리되어 있지만, 절대적인 보호가 있는 것은 아니다.==

예제 프로그램에서, 피어 스레드들은 `ptr`이라는 전역 변수를 통해 메인 스레드의 스택에 존재하는 배열 `msgs`의 내용을 간접적으로 참조한다.


## 12.4.2 변수의 메모리 매핑 (Mapping Variables to Memory)

C 언어에서 변수는 저장 클래스(storage class)에 따라 메모리에 매핑된다.


### 1️⃣ 전역 변수 (Global variables)

함수 밖에서 선언된 변수이다.
런타임 시, 가상 메모리의 읽기/쓰기 영역에는 각 전역 변수의 인스턴스가 정확히 하나만 존재하며,
모든 스레드가 이 인스턴스를 참조할 수 있다.

예제의 전역 변수 `ptr` 은 전역 메모리의 쓰기 가능한 영역에 하나의 인스턴스를 가진다.


### 2️⃣ 지역 자동 변수 (Local automatic variables)

`static` 키워드 없이 함수 내부에 선언된 변수이다.
런타임 시, 각 스레드의 스택에는 자신만의 지역 변수 인스턴스가 존재한다.

즉, 여러 스레드가 같은 함수를 실행하더라도 각자의 스택에 별도의 지역 변수가 생긴다.

예를 들어,

* `main` 함수의 지역 변수 `tid` → 메인 스레드의 스택에만 존재 (`tid.m`)
* `thread` 함수의 지역 변수 `myid` → 피어 스레드마다 하나씩 존재 (`myid.p0`, `myid.p1`)


### 3️⃣ 지역 정적 변수 (Local static variables)

`static` 키워드로 함수 안에 선언된 변수이다.
전역 변수처럼 가상 메모리의 읽기/쓰기 영역에 하나의 인스턴스만 존재한다. ==(차이점은 뭘까??)==

예제에서 `cnt`가 이에 해당한다.
비록 `thread` 함수 안에서 선언되었지만, 모든 스레드가 동일한 `cnt`를 참조하고 수정한다.


## 12.4.3 공유 변수 (Shared Variables)

어떤 변수 v가 공유(shared) 라고 부르는 조건은 다음과 같다:

> “v의 런타임 인스턴스가 두 개 이상의 스레드에 의해 참조될 때”

예제 프로그램에서:

* 공유 변수:
  `cnt`
  → 프로그램 실행 시 인스턴스가 단 하나이며, 두 스레드가 모두 참조함.

* 비공유 변수:
  `myid`
  → 각 스레드의 스택에 개별 인스턴스가 존재하며, 한 스레드만 참조함.

하지만 지역 자동 변수도 공유될 수 있다는 점에 유의해야 한다.
예를 들어, 메인 스레드의 지역 변수 `msgs`는
전역 포인터 `ptr`을 통해 피어 스레드들이 접근하므로 결과적으로 공유 변수가 된다.


### 정리

| 변수 이름  | 변수 종류                | 인스턴스 수 | 공유 여부          | 접근 스레드   |
| ------ | -------------------- | ------ | -------------- | -------- |
| `ptr`  | 전역 변수                | 1      | ✅ 공유됨          | 모든 스레드   |
| `msgs` | 지역 자동 변수 (main 내부)   | 1      | ✅ 공유됨 (ptr 통해) | 모든 스레드   |
| `tid`  | 지역 자동 변수 (main 내부)   | 1      | ❌ 비공유          | 메인 스레드   |
| `myid` | 지역 자동 변수 (thread 내부) | 2      | ❌ 비공유          | 각 피어 스레드 |
| `cnt`  | 지역 정적 변수 (thread 내부) | 1      | ✅ 공유됨          | 모든 스레드   |


이 절의 핵심은 다음과 같습니다:

> 스레드 간에 변수가 “공유”되는지는 그 저장 클래스(storage class) 와
> 스레드가 해당 인스턴스에 접근할 수 있는지 여부에 의해 결정된다.
