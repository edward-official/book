동시 프로그램을 만드는 가장 간단한 방법은 `fork`, `exec`, `waitpid` 같은 익숙한 함수==(그렇게 익숙하지는 않은데??)==들을 사용하는 프로세스(process) 기반 방식이다.
예를 들어, 동시 서버(concurrent server)를 만드는 자연스러운 접근법은 부모 프로세스가 클라이언트의 연결 요청을 수락한 다음, 각 클라이언트를 처리하기 위한 새로운 자식 프로세스를 생성하는 것이다.

![[Figure12-01.png]]

이 동작을 이해하기 위해, 두 개의 클라이언트와 하나의 서버가 있다고 가정하자. 서버는 리스닝 디스크립터(listening descriptor) (예를 들어 3번)를 통해 연결 요청을 기다리고 있다. 이제 클라이언트 1로부터 연결 요청을 수락하고, 연결된 디스크립터(예를 들어 4번)를 반환했다고 하자. (그림 12.1 참고)

![[Figure12-02.png]]

연결 요청을 수락한 후, 서버는 `fork`를 호출하여 자식 프로세스를 생성하고, 이 자식은 서버의 디스크립터 테이블을 완전히 복사한다.
==자식 프로세스는 더 이상 필요 없는 리스닝 디스크립터(3번)를 닫고, 부모 프로세스는 연결 디스크립터(4번)를 닫는다.==
이 상태는 그림 12.2에서 보듯, 자식 프로세스가 클라이언트를 처리 중인 상황이다.

부모와 자식의 연결 디스크립터가 같은 파일 테이블 엔트리를 가리키므로, 부모가 자신의 연결 디스크립터 복사본을 닫는 것이 매우 중요하다. 그렇지 않으면 파일 테이블 엔트리가 해제되지 않아 메모리 누수가 발생하고, 결국 시스템이 메모리를 소진해 충돌할 수 있다.


### Figure 12.1

단계 1: 서버가 클라이언트의 연결 요청을 수락한다.


### Figure 12.2

단계 2: 서버가 클라이언트를 처리하기 위해 자식 프로세스를 생성한다.

![[Figure12-03.png]]

![[Figure12-04.png]]

이제, 서버가 클라이언트 1의 요청을 처리하기 위해 자식을 만든 뒤, 클라이언트 2로부터 새로운 연결 요청을 수락했다고 가정하자.
이때 서버는 새 연결 디스크립터(예: 5번)를 반환한다 (그림 12.3).
부모 프로세스는 다시 `fork`를 호출하여 두 번째 자식을 만들고, 이 자식은 연결 디스크립터 5번을 사용해 클라이언트 2를 처리한다 (그림 12.4).
이 시점에서 부모는 다음 연결 요청을 기다리고 있고, 두 자식 프로세스는 각각의 클라이언트를 동시에 처리하고 있다.


### Figure 12.3

단계 3: 서버가 또 다른 연결 요청을 수락한다.

### Figure 12.4

단계 4: 서버가 새 클라이언트를 처리하기 위해 또 다른 자식 프로세스를 생성한다.

==부모는 반드시 자신의 연결 디스크립터 복사본을 닫아야 한다.== 그렇지 않으면 해당 파일 테이블 엔트리가 해제되지 않아 메모리 누수가 발생한다.
또한, 소켓의 ==파일 테이블 엔트리(커널은 모든 열린 파일에 대해 파일 테이블 엔트리를 유지합니다.)==에는 ==참조 카운트(reference count)== 가 있기 때문에, 부모와 자식의 `connfd`가 모두 닫히기 전까지는 클라이언트 연결이 종료되지 않는다.


## 12.1.1 프로세스 기반 동시 서버

그림 12.5는 프로세스 기반 동시 에코 서버(concurrent echo server) 의 코드를 보여준다.
29번째 줄에서 호출되는 `echo` 함수는 11.22절의 예제에서 가져온 것이다.

이 서버에 대해 주목해야 할 몇 가지 핵심 사항이 있다.

* (1) 서버는 일반적으로 오랜 시간 동안 실행되므로, 좀비 프로세스를 수거(reap)하기 위한 SIGCHLD 핸들러를 포함해야 한다 (4–9행).
  `SIGCHLD` 신호가 블록되어 있는 동안 핸들러가 실행되면 신호가 큐에 쌓이지 않기 때문에, 핸들러는 여러 자식 프로세스를 한 번에 처리할 수 있도록 설계되어야 한다.

* (2) 부모와 자식은 각각 자신의 `connfd` 복사본을 닫아야 한다 (33행과 30행).
  이는 특히 부모에게 매우 중요하며, 그렇지 않으면 메모리 누수가 발생할 수 있다.

* (3) 소켓의 참조 카운트 때문에, 부모와 자식 모두 `connfd`를 닫기 전까지는 클라이언트와의 연결이 완전히 종료되지 않는다.


### Figure 12.5

프로세스 기반 동시 에코 서버

부모 프로세스는 새로운 연결 요청이 있을 때마다 `fork`를 호출하여 자식 프로세스를 만들어 각 클라이언트를 처리한다.

![[Figure12-05.png]]


## 12.1.2 프로세스의 장단점

프로세스는 부모와 자식 간의 상태 공유(state sharing) 에 대해 깔끔한 모델을 제공한다.
파일 테이블은 공유되지만, 사용자 주소 공간은 공유되지 않는다.

* 장점:
  별도의 주소 공간을 가지므로, 한 프로세스가 다른 프로세스의 메모리를 실수로 덮어쓰는 일이 없어 많은 혼란스러운 오류를 방지할 수 있다.

* 단점:
  별도의 주소 공간을 가지면 프로세스 간 상태 정보를 공유하기 어려워진다.
  정보를 공유하려면 명시적인 프로세스 간 통신(IPC) 메커니즘을 사용해야 한다. ==(이게 왜 단점인지 명확하게는 모르겠는데??)==
  또한 프로세스 기반 설계는 상대적으로 느리며, 프로세스 제어(process control)와 IPC의 오버헤드가 크다.

