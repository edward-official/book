이제까지 배운 내용을 종합하여, 작지만 완전하게 동작하는 웹 서버인 Tiny를 구현하면서 네트워크 프로그래밍 논의를 마무리하겠습니다.
Tiny는 프로세스 제어, 유닉스 I/O, 소켓 인터페이스, HTTP 등 지금까지 배운 개념들을 250줄 남짓한 코드 안에 모두 담은 흥미로운 프로그램입니다.

기능이나 견고함, 보안 면에서는 실제 서버에 비해 부족하지만, 실제 웹 브라우저에 정적(static) 또는 동적(dynamic) 콘텐츠를 제공할 만큼 충분히 강력합니다.
직접 구현해보길 권합니다 — 진짜 브라우저를 켜서 자신이 만든 서버가 복잡한 웹페이지를 출력하는 모습을 보는 것은 정말 흥미로운 경험입니다!


##### Tiny의 main 루틴
![[Figure11-29.png]]
Figure 11.29는 Tiny의 메인 루틴을 보여줍니다.
Tiny는 반복(iterative) 서버로, 명령행 인자로 전달된 포트 번호에 대해 연결 요청을 기다립니다.
`open_listenfd` 함수를 호출하여 리스닝 소켓을 연 뒤, 무한 루프를 돌며 다음을 반복합니다:

1. 클라이언트의 연결 요청을 수락 (`Accept`, 32행)
2. 한 번의 트랜잭션 수행 (`doit`, 36행)
3. 연결 종료 (`Close`, 37행)


##### doit 함수
![[Figure11-30.png]]
Figure 11.30의 `doit` 함수는 하나의 HTTP 트랜잭션을 처리합니다.
먼저 요청 라인을 읽고 파싱합니다(11–14행).
이때 `rio_readlineb` 함수를 사용하여 요청을 읽습니다.

Tiny는 GET 메서드만 지원합니다.
만약 클라이언트가 다른 메서드(예: POST)를 요청하면,
오류 메시지를 전송하고 main 루틴으로 되돌아갑니다.


##### clienterror 함수
![[Figure11-31.png]]
Tiny는 실제 서버와 같은 고급 에러 처리 기능은 부족하지만, 명백한 오류에 대해서는 클라이언트에게 알립니다.
`clienterror` 함수(Figure 11.31)는 적절한 HTTP 상태 코드와 메시지를 포함한 HTML 페이지를 생성해 브라우저에 전송합니다.


##### read_requesthdrs 함수
![[Figure11-32.png]]
Tiny는 요청 헤더의 정보를 사용하지 않습니다.
단지 읽어서 무시할 뿐입니다.
`read_requesthdrs` 함수(Figure 11.32)는 요청 헤더를 한 줄씩 읽다가, 빈 줄(`\r\n`)을 만나면 종료합니다.


##### parse_uri 함수
![[Figure11-33.png]]
Tiny는 정적 콘텐츠와 동적 콘텐츠를 구분하는 간단한 규칙을 사용합니다.

* 정적 콘텐츠의 루트 디렉토리는 현재 디렉토리(`.`)
* 동적 콘텐츠(CGI 프로그램)의 루트 디렉토리는 `./cgi-bin`

`parse_uri` 함수(Figure 11.33)는 요청된 URI를 분석하여 파일 이름과 CGI 인자 문자열로 나눕니다.

예를 들어 `/index.html` 요청은 정적 콘텐츠이고, `/cgi-bin/adder?15000&213`은 동적 콘텐츠로 인식합니다.


##### serve_static 함수
![[Figure11-34.png]]
Tiny는 다섯 가지 형태의 정적 콘텐츠를 제공합니다:
HTML, 일반 텍스트, GIF, PNG, JPEG 파일.

`serve_static` 함수(Figure 11.34)는 다음 단계로 동작합니다:

1. 파일 확장자를 보고 MIME 타입을 결정 (`get_filetype`)
2. HTTP 응답 헤더 작성 및 전송
3. 파일을 열고 `mmap`으로 메모리에 매핑
4. 파일 내용을 클라이언트에게 전송
5. 매핑 해제 (`munmap`)

이 함수는 Linux의 `mmap`을 사용하여 파일을 메모리에 직접 매핑한 뒤,
`rio_writen`으로 빠르게 클라이언트로 전송합니다.


##### serve_dynamic 함수
![[Figure11-35.png]]
`serve_dynamic` 함수(Figure 11.35)는 CGI 프로그램을 실행하여 동적 콘텐츠를 생성합니다.
절차는 다음과 같습니다:

1. HTTP 응답의 첫 부분(상태 줄과 헤더)을 전송
2. `fork()`로 자식 프로세스 생성
3. 자식 프로세스가 `QUERY_STRING` 환경 변수를 설정하고
   `dup2()`를 사용해 표준출력을 클라이언트 소켓으로 리디렉션
4. `execve()`로 CGI 프로그램 실행
5. 부모는 `wait()`으로 자식 종료를 기다림


##### 부록: 연결이 조기에 종료될 때의 처리

웹 서버는 간단히 보이지만, 견고하게 만드는 일은 쉽지 않습니다.
특히 장시간 안정적으로 실행되려면 리눅스 시스템 프로그래밍에 대한 깊은 이해가 필요합니다.

예를 들어, 클라이언트가 브라우저의 “중지(Stop)” 버튼을 눌러 연결을 강제로 종료하면 서버의 다음 `write()` 호출에서 SIGPIPE 시그널이 발생합니다.

이 시그널의 기본 동작은 프로세스를 종료하는 것입니다.
따라서 견고한 서버는 SIGPIPE 시그널을 처리하거나, `write()` 호출에서 EPIPE 오류를 검사하여 안전하게 동작해야 합니다.

