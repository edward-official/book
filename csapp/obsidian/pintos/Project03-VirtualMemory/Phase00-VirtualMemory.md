![[VirtualMemory.png]]
#### 커널 영역에 유저 풀과 커널 풀이 별도로 존재하는 이유가 뭐지??
- 사용자 프로세스가 과도하게 할당하거나 메모리 누수를 남겨서 커널이 필요한 메모리를 뺏기는 상황을 방지하기 위해서 나누어 관리하는 것.
- 사용자 공간이 부족하다면 스왑 아웃으로 처리하는 설계.

#### 페이지 구조체(struct page)에 필요한 데이터 타입은 어디에 있지??
- 내부 멤버 중 const struct page_operations이 갖고 있다.
- 타입에 따라서 swap, destroy 동작이 달라지기 때문에 이렇게 묶어서 저장하는 것 같다.

#### 디스크에 쓰기위한 접근을 최소화 하는 방식
- pml4_is_dirty, pml4_set_dirty같은 함수를 사용할 수 있다.
- 페이지를 스왑 아웃하거나 언맵할 때만 디스크에 접근하는 방식으로 오버헤드를 줄인다.

#### 페이지를 스왑 아웃하는 것과 언맵하는 게 다른건가??
- 명백히 다르다.
- palloc으로 받은 페이지를 반환하는 과정을 예시로 들어보자.
- 스왑아웃하는 경우에는 나중에 써야한다는 뜻이니 디스크에 저장을 해야하고 언맵하는 경우에는 그냥 삭제해버리면 된다.

#### struct page의 va와 struct frame의 kva는 뭐가 다른거지??
- va는 프로세스 입장에서의 사용자 가상 주소
- kva는 커널 입장에서의 커널 가상 주소
- 즉, 이 둘은 같은 물리프레임을 가르킵니다.
- 이걸 가능하게 하는 게 바로 install_page 함수 안에 있는 pml4_set_page 함수

