## 스레드가 생성될 때 할당받는 페이지는 대체 어떤 놈인가??
```
tid_t
thread_create (const char *name, int priority,
		thread_func *function, void *aux) {
	struct thread *t;
	tid_t tid;

	ASSERT (function != NULL);

	/* Allocate thread. */
	t = palloc_get_page (PAL_ZERO); /* 🔥 edward: Thread gets page */
	if (t == NULL)
		return TID_ERROR;

	/* Initialize thread. */
	init_thread (t, name, priority);
	tid = t->tid = allocate_tid ();
	if (thread_mlfqs) {
		t->nice = thread_current ()->nice;
		t->recent_cpu = 0;
		mlfqs_update_priority (t);
	}

	/* Call the kernel_thread if it scheduled.
	 * Note) rdi is 1st argument, and rsi is 2nd argument. */
	t->tf.rip = (uintptr_t) kernel_thread;
	t->tf.R.rdi = (uint64_t) function;
	t->tf.R.rsi = (uint64_t) aux;
	t->tf.ds = SEL_KDSEG;
	t->tf.es = SEL_KDSEG;
	t->tf.ss = SEL_KDSEG;
	t->tf.cs = SEL_KCSEG;
	t->tf.eflags = FLAG_IF;

	/* Add to run queue. */
	thread_unblock (t);
	check_preemption();
	return tid;
}
```

#### 자 일단 이 함수의 동작을 이해해보자.
1. 페이지 하나를 할당받는다.
2. 페이지에 스레드 구조체를 설정한다.
3. 나머지 공간을 스레드 스택으로 활용하기 위해서 스택 포인터를 설정해준다.

#### 페이지 할당 함수의 내부 동작도 알아보자.
```
void *
palloc_get_page (enum palloc_flags flags) {
	return palloc_get_multiple (flags, 1);
}
```
커널의 페이지 할당기에서 **한장의 물리 페이지**를 받아오는 헬퍼 함수
내부적으로 palloc_get_multiple에 page_cnt를 1로 넘겨주는 형태
옵션:
- **PAL_USER**: **사용자 풀에서 페이지**를 가져옵니다. 이 비트를 빼면 **기본적으로 커널 풀에서 할당**합니다.
- **PAL_ZERO**: **새 페이지를 0으로 채워서 돌려줍니다.** 초기화를 원하지 않으면 빼두면 됩니다.
- **PAL_ASSERT**: 할당할 페이지가 없을 때 NULL을 돌려주는 대신 **커널 패닉을 일으켜 즉시 중단**합니다.
- **0**: 위 비트를 아무 것도 주지 않은 **기본값**입니다. 즉 커널 풀에서 페이지 하나를 0으로 초기화하는 과정 없이 가져오되 실패 시 NULL을 반환합니다.

#### 그러면 생기는 질문들
- thread_create 함수를 보면 페이지를 하나만 할당받는데 이 공간이 부족하면 어떻게 될까?
- thread_create에 보면 **페이지 내부에 스레드 구조체가 들어가고 남는 부분이 스택**으로 사용되는 것 같은데, 프로세스의 **데이터/코드 영역이나 힙, 메모리 매핑 영역은 스레드간 공유**되기 때문에 이 페이지와는 상관이 없는건가?
- 음 thread_create에서 palloc_get_page를 호출할 때는 PAL_USER 값을 안주는데 **스레드가 유저 프로그램 용이면 문제**가 되는거 아닌가??
- **커널은 프로세스가 아니라고** 하는데, 그럼 뭐가 다른 걸까?? 프로세스는 보통 유저 프로세스를 말하는건가?? 그럼 **커널에는 가상 메모리 개념이 적용**이 안되는거겠지??

#### 와 완전히 몰랐던 부분이 있었다.
사용자 프로그램의 내부에서 여러 스레드들이 스택을 따로 가진다는 것은 알고 있었지만, 좀 이해가 부족했던 부분이 있었다.
그 부분은 바로 사용자 프로그램 내부의 모든 스레드는 사용자 스택 + 커널 스택을 각각 가진다는 것이다.
따라서 위에서 했던 질문들 중 일부는 내 개념 이해 자체가 부족해서 생겨났다고 볼 수 있는 것 같다.

#### 또 하나 몰랐던 사실
프로세스 내부의 스레드들이 코드/데이터 영역, 힙은 공유하고 스택은 독립적으로 관리한다는 말은 주로 커널 영역을 제외하고 사용자 영역만 두고하는 말이었다.
커널 영역은 전체 메모리에서 하나밖에 존재하지 않기 때문에 서로 다른 프로세스들 내부의 스레드들도 모두 같은 커널 영역을 참고해야하고 사용자 스레드던 커널 스레드던 모든 스레드들은 각자의 커널 스택을 가져야만 하는 것이다.
반대로 당연하게도 커널 스레드는 사용자 스택을 가지지 않고 사용자 스레드만 사용자 스택을 가진다.

#### 질문 1: 스레드가 커널 스택으로 페이지 하나만 할당 받는데, 이 공간이 부족하면 어떻게 될까?
일단 핀토스에서는 커널 스택의 공간이 4KB로 고정적이다.
따라서 이 공간이 부족하면 오버플로우가 나고 프로그램이 죽는다.
그래서 핀토스에서 커널 코드를 작성할 때 하면 안되는 몇가지 사항들이 있다.
- 너무 큰 크기의 정적인 지역변수를 선언하기
- 깊은 재귀 호출
- 크기가 큰 값을 통째로 복사 (ex 구조체)
이런 문제는 동적 할당을 통해서 힙을 이용하거나, 새로운 페이지를 잠시동안 할당받아서 우회하는 방법이 있다.

#### 질문 2: 사용자 프로그램의 데이터/코드 영역과 힙, 메모리 영역은 스레드간 공유되기 때문에 이 함수 내부에서 할당받는 페이지와 상관이 없는 것인가?
이건 질문 자체가 잘못되었다고 볼 수 있다.
왜냐하면 thread_create 함수는 커널 스레드를 생성하는 함수이기 때문에 이 함수에서 생성하는 페이지도 커널 스택을 위한 공간이라고 할 수 있다.
다만 스레드간 공유하는 부분과 그렇지 않은 부분을 파악하려는 질문의 의도는 좋았던 것 같다.

#### 질문 3: 스레드가 유저 프로그램 용이면 문제가 되는 거 아닌가?
이 역시 질문 자체가 잘못되었다.
앞서 말했던 대로 모든 스레드는 커널 스택을 가져야하고 이 부분은 그 커널 스택을 할당해 줄 뿐이다.

#### 질문 4: 커널은 프로세스가 아니라고 하는데 뭐가 다른거야??
![[comparison.png]]
프로세스라고 말하면 당연히 사용자 프로그램을 말하는 것이고 커널은 프로세스와는 다른 개념이기 때문에 커널에는 가상 메모리의 개념도 적용이 안된다.

