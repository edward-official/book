#### 과제 목표
1. 우선 stdin과 stdout을 열고 닫을 수 있도록 해야한다. (예를 들어 stdin이 닫혀있다면 입력을 받아오면 안된다.)
2. 그리고 파일 디스크립터를 복제하는 dup2 함수를 구현해야한다.
3. 파일 오프셋과 상태 플래그들도 동기화가 되어야한다. (즉 하나의 파일 오프셋이 seek 함수로 바뀐다면 그 파일을 가리키는 모든 파일 디스크립터의 오프셋이 같이 변경되어야한다.)
4. 포크가 되어도 복제된 파일디스크립터 리스트가 모두 유지되어야한다.

#### 내 구현 계획
1. 지금은 스레드 구조체에 파일 디스크립터 리스트를 유지하고 있는데, 파일 리스트로 바꾸고, 파일 리스트 내부에 파일 디스크립터 리스트를 유지하는게 맞는것 같다.
2. 그렇게 하면 특정 파일을 변경할때 거기에 딸린 파일 디스크립터를 수정할 필요는 없으니까 동기화 난이도는 내려갈 것 같다.
3. 그런데 문제는 지금 스레드 구조체에 파일 디스크립터를 유지했었기 때문에 내부적으로 파일 디스크립터를 썼던 함수를 모두 수정해야할 것 같다... (코드 수정량이 엄청 많을 듯 ㅠ)

#### GPT가 내 구현 계획에 대해 남겨준 피드백
파일 리스트 안에 파일 디스크립터 리스트를 두는 구조는 close/read/write 등 대부분의 함수가 파일 디스크립터 기반이기 때문에 비효율적이다.

#### 궁금증
- stdin이 닫혀있다면 입력을 받아오면 안된다고 했는데 그럼 어디 버퍼링을 해둬야하나??
  버퍼링같은 동작은 필요없고 그냥 유효하지 않은 동작으로 판단하고 -1 반환을 해야하는 듯하다.
- 파일 오프셋과 상태 플래그가 뭐지??
  아니 생각해보니깐 읽기도 되고 쓰기도 되는 파일이면 오프셋이 하나면 어떻게 그 두개를 관리하지??
  그리고 계속 다른 부분을 읽고 쓸 수도 있을건데?? 그때 seek를 쓰는 건가??
  음 seek가 필요한 이유가 내가 생각했던 게 맞는 것 같다.
  또 상태 플래그는 일단 여기서는 deny_write밖에 없는 것 같다.
- 파일을 열면 그 파일 내용이 메모리로 올라오게 될 텐데 그렇다면 페이지 테이블의 어떤 가상 메모리 영역에 매핑되는거지?
  파일에 쓰고 읽을 때는 버퍼를 통하기 때문에 디스크 내용을 메모리로 복제하지는 않는다.
  버퍼는 커널에 동적할당되어 힙을 사용하는 형태로 동작한다.
- 파일이 오픈되면 파일 구조체 내부에 어떻게 inode 멤버가 배정이 되는거지?
  이건 그냥 filesys_open 함수 내부에서 dir_lookup 함수가 inode를 설정해주는 것 같다.
- 음 같은 프로세스(스레드) 내부에서 같은 파일을 열고 다시 열려고 시도하면 어떻게 되는거지??
  새 파일 구조체 변수가 생기지만 결국 같은 inode 구조체를 참조하는 형태가 된다.
- inode 구조체는 도대체 뭐지??
  파일 메타데이터 구조체
- 포크를 할 때 파일 디스크립터 테이블을 복제하게 되는데, 그 내부적으로 파일 구조체까지 복사가 되는건가??


#### 구현 단계 기록
+ 어떻게 stdin/stdout을 열고 닫을 수 있도록 구현하지?
- 내 생각에는 스레드 구조체에 int stdin_counter, stdout_counter를 두면 될 것 같은데....
- 이 방식은 안되고 0,1번에도 파일 디스크립터 구조체를 연결하되 fd 타입 멤버를 추가해줘서 관리하면 될 것 같다.
+ 파일 디스크립터를 복제하는 dup2 함수를 구현해야한다.
- 새로운 파일 디스크립터 구조체를 생성하고 file_duplicate 함수를 이용해서 복제된 파일 객체만 연결해주면 될 듯.
- 물론 디스크립터 값을 복제하고 리스트 원소를 프로세스(스레드) 구조체의 디스크립터 리스트에 넣는 과정도 필요하다.
+ 동기화 로직 (파일 오프셋, 상태 플래그)
- 내 생각에는 필요 없을 것 같다.
- 왜냐하면 어차피 이런 동기화해야하는 대상들은 파일 구조체 내부에 있고 여러 디스크립터가 하나의 파일 구조체를 참조하는 구조이기 때문에..
- 하지만 파일을 닫을 때 그 파일에 해당하는 디스크립터를 모두 닫아줘야하기 때문에 리스트를 순회하면서 조건에 따라 삭제하는 로직은 필요할 듯. 🔥
- 프로세스가 종료할 때도 하나의 파일 객체를 여러번 삭제하는 오류가 없도록 내부 상태를 살펴보고 수정이 필요하면 그 부분을 수정하면 될 듯하다. 🔥
+ 포크에서 뭘 더 복제해야하지?
- 내 생각에는 파일 디스크립터는 이미 복제하는 로직이 있고 거기서 파일 구조체까지 복사가 되기 때문에 추가적으로 로직을 추가할 필요는 없을 것 같다.

프로세스를 만들 때 fd 0,1에 각각 표준입출력을 만들어주자.
close_fd에서 ref_cnt가 0일때만 닫기 수행
유효하지 않은 write/read가 있으면 그냥 바로 exit해도 될까?