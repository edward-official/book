리눅스에서는 여러 프로세스가 동일한 파일을 다양한 방식으로 공유할 수 있다.
이를 이해하려면 커널이 파일을 어떻게 표현하는지를 알아야 한다.

커널은 열린 파일(open file)을 세 가지 관련된 테이블 구조로 관리한다.


##### 1️⃣ 디스크립터 테이블 (Descriptor table)

* 각 프로세스마다 독립적으로 존재한다.
* 인덱스는 파일 디스크립터(fd) 번호이며,
  각 엔트리는 파일 테이블(file table)의 항목을 가리킨다.


##### 2️⃣ 파일 테이블 (File table)

* 모든 프로세스가 공유하는 구조.
* 각 엔트리는 다음 정보를 가진다:

  * 파일 위치 (file position)
  * 참조 카운트 (reference count)
  * v-node 테이블의 포인터

파일이 닫히면 참조 카운트가 감소하고,
0이 되면 커널은 그 엔트리를 제거한다.


##### 3️⃣ v-node 테이블 (v-node table)

* 커널의 모든 열린 파일에 대해 존재하며 모든 프로세스가 공유한다.
* `stat` 구조체의 주요 정보(`st_mode`, `st_size` 등)를 포함한다.


##### Figure 10.12 — 일반적인 경우

두 개의 디스크립터(예: fd1, fd4)가 서로 다른 파일을 참조하는 경우:

* 각 디스크립터는 독립적인 파일 테이블 엔트리를 가짐
* 파일 간 공유는 없음


##### Figure 10.13 — 파일 공유의 경우

두 개의 디스크립터가 동일한 파일을 다른 파일 테이블 엔트리를 통해 참조할 수도 있다.
예를 들어 같은 파일을 두 번 `open`하면 이렇게 된다.
각 디스크립터는 서로 다른 파일 위치(file position)를 가지므로
한쪽에서 읽은 위치가 다른 쪽에는 영향을 주지 않는다.


##### Figure 10.14 — 부모-자식 프로세스의 파일 공유

`fork()`가 호출되면 자식 프로세스는 부모의 디스크립터 테이블을 복제한다.
즉, 자식은 부모와 같은 파일 테이블을 공유하므로,
같은 파일 위치를 공유하게 된다.

이 경우:

* 참조 카운트(`refcnt`)는 2가 된다.
* 부모와 자식 모두 `close()`를 호출해야 커널이 실제 파일을 닫는다.

