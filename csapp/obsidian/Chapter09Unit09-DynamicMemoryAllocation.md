저수준 함수 ==mmap()==에 대한 간략한 설명: [네이버 블로그](https://blog.naver.com/pmdrdocg/224052320974)

###### Figure 9.33
![[Figure09-33.png]]
###### dynamic memory allocator
프로세스의 힙(heap) 영역에서 필요한 만큼의 메모리를 할당하고 해제해주는 시스템 혹은 라이브러리
- 할당기는 힙을 다양한 크기의 블록들로 관리합니다.
- 각 블록은 연속된 메모리 공간입니다.

두가지 스타일의 할당기가 있는데, 할당된 블록을 누가 언제 해제하느냐가 그 둘의 차이점입니다.
- Explicit Allocator: 응용 프로그램이 직접 블록을 해제해야합니다.
- Implicit Allocator: 할당기가 자동으로 감지하여 해제합니다. ==(garbage collection)==

#### 9.9.1 The malloc and free Functions
###### 참고
3장에서 배웠듯이, 인텔은 4바이트 객체를 더블워드(double word) 라고 부른다.
하지만 여기서는 일반적인 용어를 따라 word = 4바이트, double word = 8바이트 로 정의한다.

###### 블록 주소의 정렬
- 32비트 모드에서는 블록의 시작 주소가 8의 배수로 정렬
- 64비트 모드에서는 블록의 시작 주소가 16의 배수로 정렬
이건 곧 내가 24바이트 크기의 공간을 할당해도 ==실제로는 32바이트가 확보==될 수 있다는 것.

###### 오류 처리
요청한 크기가 너무 크거나, 가상 메모리가 부족하면 malloc은 NULL을 반환하고 ==errno==를 ENOMEM으로 설정한다.

###### sbrk
```
#include <unistd.h>

void *sbrk(intptr_t incr);
```
- 반환값: 성공 시 이전 ==brk(힙 영역의 끝)== 포인터, 실패 시 -1.
- sbrk(incr)은 커널의 brk 포인터를 incr 바이트만큼 ==늘리거나 줄인다==.
- 음수 값을 주면 힙을 줄일 수 있지만 ==주의==해야 한다.

###### free
```
#include <stdlib.h>

void free(void *ptr);
```
- 반환값: None.
- ptr은 malloc, calloc, realloc로 얻은 블록의 시작 주소여야 한다.
- free는 반환값이 없기 때문에, ==잘못된 포인터를 넘겨도 프로그램은 즉시 오류를 알 수 없다==.

###### Figure 9.34
![[Figure09-34.png]]
#### 9.9.2 Why Dynamic Memory Allocation?
프로그램이 실행되기 전에 데이터 구조의 크기를 정확히 알 수 없는 경우가 많습니다.
따라서 동적 할당은 프로그램에서 필수적입니다.

#### 9.9.3 Allocator Requirements and Goals
###### 명시적 할당기의 제약 조건
1️⃣ 임의의 요청 시퀀스 처리 가능
- malloc과 free 요청의 순서가 임의적일 수 있음.
- 모든 free는 반드시 이전에 malloc된 블록에 대응해야 함.

2️⃣ 즉각적인 응답
- 재정렬 없이 즉시 할당 수행해야 함.

3️⃣ 힙만 사용
- ==할당기가 사용하는 모든 자료구조==(메모리 할당을 위해서 할당기가 사용하는 자료구조)는 힙 내에 존재해야 함.

4️⃣ 블록 정렬(Alignment)
어떤 타입의 데이터도 저장할 수 있도록 정렬되어야 함. (이게 무슨 말인지 모르겠네??)

5️⃣ 할당된 블록은 수정 금지
이미 할당된 블록의 위치나 내용을 바꿀 수 없음. (즉, ==compaction== 불가)

###### 할당기의 목표
1. 처리량(throughput) 최대화
2. 메모리 활용도(utilization) 최대화

#### 9.9.4 Fragmentation
메모리 낭비의 주요 원인.
사용되지 않은 공간이 존재하지만 새로운 요청을 만족시킬 수 없는 현상.

###### Internal Fragmentation
- 할당된 블록이 실제 요청 크기보다 클 때 발생.
- 예: 정렬을 맞추기 위해 여분의 공간 추가.
- 크기 차이의 총합으로 계산 가능.

###### External fragmentation
- 전체적으로는 빈 공간이 충분하지만, 하나의 큰 요청을 만족시킬 만큼 연속적이지 않을 때 발생.
- 예: 여러 개의 작은 빈 블록이 흩어져 있는 경우.
- 외부 단편화는 예측 불가능하고, 대부분의 할당기는 휴리스틱(heuristic)으로 이를 완화한다.

#### 9.9.5 Implementation Issues
가장 단순한 할당기는 힙을 단순한 바이트 배열로 두고, 포인터 p만 관리한다.
- malloc(size): p를 size만큼 증가시키고 이전 값 반환
- free(ptr): 아무 일도 하지 않음
처리량은 매우 높지만 재사용 불가 즉, 메모리 낭비 심함

실제 할당기는 다음 네 가지 문제를 모두 해결해야 한다.
- 자유 블록 관리 (Free block organization)
- 배치 전략 (Placement)
- 분할 (Splitting)
- 병합 (Coalescing)

#### 9.9.6 Implicit Free Lists
실제 할당기는 각 블록의 경계를 구분하고 “할당됨/비어 있음”을 식별할 수 있는 구조가 필요하다.
가장 간단한 방법은 헤더(header)를 사용하는 것이다.

###### Figure 9.35
![[Figure09-35.png]]

###### Figure 9.36
![[Figure09-36.png]]
암시적 자유 리스트에서는 모든 블록을 연속적으로 순회하면서 헤더 정보를 통해 자유 블록을 찾습니다.
- 장점: 구현이 단순
- 단점: 순회 비용이 O(n)

###### 최소 블록 크기
- 정렬 제약과 헤더 형식으로 인해 최소 블록 크기 = 2워드 (8바이트)가 됩니다.
- 따라서 1바이트만 요청해도 8바이트가 할당됩니다.

#### 9.9.7 Placing Allocated Blocks
응용 프로그램이 크기 k 바이트의 블록을 요청하면, 할당기는 자유 리스트(free list)에서 요청 크기를 만족시킬 수 있는 충분히 큰 블록을 찾습니다.
이때 어떤 방식을 사용해 탐색할지는 배치 정책(placement policy)에 의해 결정됩니다.
다음은 3가지의 일반적 배치 정책입니다.

###### First fit (최초 적합)
자유 리스트의 처음부터 탐색하여, 처음 발견한 충분히 큰 블록을 선택한다.
- 장점: 빠르다. 큰 블록을 리스트 끝에 남겨두는 경향이 있어 나중에 쓸 수 있다.
- 단점: 리스트 앞부분에 작은 “쪼가리(splinters)” 블록이 남아, 큰 블록을 찾는 시간이 점점 길어짐.


###### Next fit (다음 적합)
First fit과 비슷하지만, 이전 탐색이 끝난 지점부터 다시 탐색을 시작한다.
이 방식은 도널드 크누스(Donald Knuth) 가 제안한 것으로, “이전에 적합한 블록을 찾은 근처에서 다음에도 찾을 수 있을 것이다”라는 경험적 가정에 기반한다.
- 장점: front 부분이 잘게 쪼개지는 것을 방지하므로, first fit보다 빠를 수 있다.
- 단점: 메모리 활용률은 first fit보다 나쁠 수 있음.


###### Best fit (최적 적합)
모든 자유 블록을 검사하여 요청을 만족하는 가장 작은 블록을 선택한다.
- 장점: 메모리 활용률이 가장 좋음.
- 단점: 탐색 비용이 큼 (자유 리스트 전체를 순회해야 함). 따라서 암시적 자유 리스트(implicit free list)에서는 비효율적.

#### 9.9.8 Splitting Free Blocks
할당기가 적합한 자유 블록을 찾으면, 그 블록을 얼마나 쪼개서 할당할지 결정해야 한다.

가장 단순한 방법은 해당 자유 블록 전체를 통째로 사용하는 것이다.
이 경우 간단하지만 내부 단편화(internal fragmentation) 가 발생한다.

더 효율적인 방법은 블록을 두 부분으로 나누는 것(split) 이다.
- 앞부분: 할당된 블록
- 나머지: 새로운 자유 블록

###### Figure 9.37
![[Figure09-37.png]]

#### 9.9.9 Getting Additional Heap Memory
만약 자유 리스트에서 요청을 만족하는 블록을 찾을 수 없다면?
- 인접한 자유 블록들을 ==병합(coalescing)== 해서 큰 블록을 만들거나
- 그래도 부족하면 커널에 새로운 ==힙 메모리를 요청==한다.
이때 사용되는 함수가 ==sbrk()== 이다.
할당기는 커널로부터 받은 새 메모리를 하나의 큰 자유 블록으로 변환하고 자유 리스트에 삽입한 후, 해당 블록 일부를 할당한다.

#### 9.9.10 Coalescing Free Blocks
어떤 블록이 free 될 때, 그 양옆 블록이 비어 있는 경우가 있을 수 있다.
이들을 병합하지 않으면, 작은 자유 블록들이 흩어진 “거짓 단편화(false fragmentation)”가 발생한다.

###### Figure 9.38
![[Figure09-38.png]]

###### 병합의 2가지 전략
- 즉시 병합 (Immediate Coalescing): 블록이 해제될 때마다 즉시 인접한 자유 블록과 병합.
- 지연 병합 (Deferred Coalescing): 일단 자유 블록을 그대로 두고, 나중에 필요할 때(예: malloc 실패 시) 전체 힙을 스캔하며 병합.

즉시 병합은 간단하지만, 반복된 malloc/free 패턴에서는 불필요한 병합·분할로 인한 ==thrashing==이 생길 수 있다.
실제 구현에서는 두 방법을 절충해서 사용하기도 한다.

#### 9.9.11 Coalescing with Boundary Tags
인접한 다음 블록(next block)을 병합하는 것은 쉽다.
현재 블록의 헤더를 보면 다음 블록의 헤더 주소를 바로 알 수 있기 때문이다.

문제는 이전 블록(previous block)을 병합하는 경우다.
암시적 자유 리스트에서는 이전 블록의 위치를 찾기 위해 힙의 앞에서부터 모든 블록을 탐색해야 하므로 시간 복잡도가 O(n)이 된다.

###### 경계 태그 (Boundary Tag)
도널드 크누스(Donald Knuth) 가 제안한 방법.
각 블록의 끝에 footer (경계 태그) 를 추가하여 블록 크기와 상태(할당/자유)를 중복 저장한다.

이렇게 하면 현재 블록의 바로 앞 단어를 확인해 이전 블록의 크기와 상태를 즉시 알 수 있다.
따라서 병합을 상수 시간(constant time) 에 수행 가능하다.

###### 경계 태그의 장단점
- 장점: 이전/다음 블록 모두 즉시 접근 가능 → 빠른 병합
- 단점: 각 블록마다 헤더 + 푸터를 저장해야 하므로 작은 블록이 많을 경우 메모리 낭비가 커짐

###### 푸터 최적화
할당된 블록에는 푸터가 필요하지 않다.
푸터는 이전 블록이 비어 있을 때만 필요하므로, 헤더의 일부 비트를 활용해 이전 블록의 상태(할당/자유)를 저장하면 할당 블록의 푸터를 생략할 수 있다. (약간 이해가 어렵네??)

#### 9.9.12 Putting It Together: Implementing a Simple Allocator
즉시 병합(immediate coalescing)을 사용하는 ==암묵적 자유 리스트(implicit free list)== 기반의 단순한 할당자 구현 과정을 단계적으로 살펴보자.

==최대 블록 크기==: $2^{32} = 4\text{GB}$
이 코드는 `gcc -m32` 또는 `gcc -m64` 옵션으로 ==32비트/64비트== 프로세스 모두에서 사용할 수 있다.

