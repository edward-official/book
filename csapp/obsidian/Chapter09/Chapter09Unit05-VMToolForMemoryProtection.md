모든 현대적인 컴퓨터 시스템은 **운영체제가 메모리 접근을 제어할 수 있는 수단**을 제공해야 합니다.
사용자 프로세스는 다음과 같은 일을 해서는 안 됩니다.

* 자신의 **읽기 전용(read-only)** 코드 섹션을 수정하거나,
* 커널의 코드나 데이터 구조를 읽거나 수정하거나,
* 다른 프로세스의 개인 메모리에 접근하거나,
* 다른 프로세스와 공유되는 가상 페이지를 임의로 수정하는 것.

이러한 경우는 오직 **운영체제가 명시적으로 허락했을 때만** 가능해야 합니다
(예: 프로세스 간 통신을 위한 시스템 콜을 통해 허용되는 경우).

#### 가상 주소 공간 분리의 역할

앞서 살펴본 것처럼, 각 프로세스마다 별도의 가상 주소 공간을 두는 것은 프로세스 간 개인 메모리를 격리(isolate)하기 쉽게 만듭니다.

그러나 **주소 변환(address translation)** 메커니즘은 이를 한 단계 더 발전시켜 **가상 페이지 단위로 세밀한 접근 제어**를 구현할 수 있습니다.

CPU가 주소를 생성할 때마다 **주소 변환 하드웨어(MMU)** 는 해당 주소의 **페이지 테이블 엔트리(PTE)** 를 읽습니다.
이 PTE에 접근 권한 비트를 추가하면 가상 페이지별로 접근을 제어할 수 있습니다.

#### PTE의 권한 비트 (Permission Bits)

이 예시에서는 각 PTE에 **3개의 권한 비트(permission bits)** 를 추가했습니다:

| 비트 이름                | 의미                           |
| -------------------- | ---------------------------- |
| **SUP (Supervisor)** | 페이지 접근 시 CPU가 커널 모드인지 여부를 검사 |
| **READ**             | 페이지 읽기 허용 여부                 |
| **WRITE**            | 페이지 쓰기 허용 여부                 |

* **커널 모드**(supervisor mode)에서는 모든 페이지 접근이 가능합니다.
* **사용자 모드**(user mode)에서는 SUP 비트가 0인 페이지만 접근 가능합니다.

#### 권한 위반과 예외 처리

만약 명령어가 이러한 접근 권한을 위반하면, CPU는 **일반 보호 예외(general protection fault)** 를 발생시킵니다.
이 예외는 커널의 예외 처리기(exception handler)로 제어를 넘기며, 커널은 해당 프로세스에 **SIGSEGV 신호**를 보냅니다. (segmentation fault)

#### 페이지 테이블

페이지 테이블은 가상 메모리의 커널 영역에서 관리되며, 각 PTE는 다음 필드를 가집니다:

1. Valid
2. Supervisor
3. Read
4. Write
5. Address

즉, 가상 메모리는 단순히 주소를 변환하는 역할을 넘어
**페이지 단위의 접근 제어(Access Control)** 를 구현함으로써
시스템 전반의 **메모리 보호(Memory Protection)** 기능을 제공합니다.
