1. Signal Terminology
2. Sending Signals
3. Receiving Signals
4. Blocking and Unblocking Signals
5. Writing Signal Handlers
6. Synchronizing Flows to Avoid Nasty Concurrency Bugs
7. Explicitly Waiting for Signals

이 파트에서는 리눅스 시그널이라는 고수준의 예외 흐름을 공부합니다.
시그널이란 어떤 이벤트를 프로세스에게 알리는 메세지를 말합니다.

#### 01-Signal Terminology
1. 시그널 보내기
2. 시그널 받기
3. 펜딩/블락 시그널
4. 펜딩/블락 비트 벡터
5. 시그널 핸들러

#### 02-Sending Signals
###### 프로세스 그룹
기본적으로 부모와 자식은 같은 그룹에 속한다.
하지만 setpgid() 함수를 통해서 특정 프로세스의 그룹 변경을 할 수 있다.
###### 시그널을 보내는 방법
1. /bin/kill
2. keyboard (UNIX Shell)
	- 유닉스 셸은 job 개념을 사용한다.
	- 이는 단일 명령줄에 있는 프로세스의 집합이다.
	- 어느 한 시점에 포어그라운드 작업은 적어도 1개 이상, 백그라운드 작업은 적어도 0개 이상이 존재한다.
	- 셸이라는 것도 하나의 프로세스이다.
	- 그 셸을 통해서 실행되는 프로세스는 그 하위로 들어간다. (셸의 내부에서 실행되는 프로세스는 셸과 부모-자식 관계는 아니겠지??)
3. kill()
4. alarm()

#### 03-Receiving Signals
###### 시그널 수신 절차
커널 모드에서 사용자 모드로 전환할 때(예를 들어서 시스템 콜이 끝나거나, 컨텍스트 스위치 후) 커널은 언블럭 시그널 중 보류 중인 시그널 집합을 검사한다. 만약 그 집합이 비어있다면 커널은 해당 프로세스 p의 논리적 제어 흐름 내 다음 명령어로 제어를 넘겨준다. 그렇지 않다면, 커널은 그 중 일부의 시그널을 선택하고 프로세스 p가 그 시그널들을 수신하도록 강제하고 프로세스가 특정 동작(아마 시그널 핸들러)를 수행하고 프로세스 p의 논리적 제어 흐름 내 다음 명령어로 돌아간다. (아니 왜 일부만이야. 전부 다 해야하는거 아닌가??)
###### 각 시그널의 기본 동작 (다음 중 하나)
1. 프로세스를 종료한다.
2. 프로세스를 종료하고 코어 덤프를 남긴다. (코어 덤프가 뭐야??)
3. 프로세스를 일시중지하고 재개 시그널이 올 때까지 기다린다.
4. 시그널을 무시한다.
###### 특정 시그널의 기본 동작은 변경 가능하다.
이를 위해서 signal() 함수를 이용할 수 있습니다. (단, 스탑과 킬 시그널은 변경 불가능합니다.)
시그널 함수의 3가지 활용 방법
- 시그널 핸들러(사용자 정의 함수)를 연결
- 디폴드 메크로 연결
- 무시 메크로 연결
###### 용어 정리
- 시그널 포착: 핸들러가 호출되는 것
- 시그널 처리: 핸들러가 실행되는 것
###### 시그널 핸들러 호출 방식
1. 프로세서가 시그널을 포착하면 그 시그널에 연결된 핸들러가 호출됩니다.
2. 그리고 시그널의 정수형 인자가 핸들러의 매개변수로 전달됩니다. (즉, 하나의 핸들러가 여러 종류의 시그널을 구분해서 처리할 수 있습니다.)
3. 핸들러가 종료되면 제어 흐름은 시그널이 인터럽트했던 지점의 다음 명령어로 넘어가게 됩니다. (단, 일부 시스템에서는 인터럽트된 시스템 콜이 오류로 즉시 반환될 수도 있습니다.)
###### Figure 8.31
시그널 핸들러는 다른 시그널 핸들러에 의해 interrupt될 수 있다.

#### 04-Blocking and Unblocking Signals
###### 시그널 차단의 2가지 매커니즘
암묵적(implicit) 매커니즘
- 커널은 현재 핸들러가 처리중인 시그널과 동일한 시그널을 자동으로 차단한다.
- 동일한 시그널은 보류 상태가 될 수는 있지만 응용 프로그램으로 전달될 수는 없다.
명시적(explicit) 매커니즘
- sigprocmask() 메서드를 이용해서 특정 시그널을 명시적으로 차단/해제할 수 있다.

#### 05-Writing Signal Handlers
###### 시그널 핸들링이 까다로운 이유
1. 시그널 핸들러는 메인 프로그램과 동시에 실행되며, 같은 전역 변수를 공유한다. 이 때문에 핸들러는 메인 프로그램 또는 다른 핸들러의 동작을 방해(interrupt)할 수 있다. (어디선가 핸들러는 메모리에만 쓸 수 있고 캐시나 레지스터에는 값을 수정할 수 없다고 들었는데 사실인가??)
2. 시그널이 언제 어떤 순서로 도착하는 지에 관한 규칙이 직관적이지 않다.
3. 시스템마다 시그널 처리 방식이 다르다.
###### 보수적인 시그널 핸들링 가이드라인
1. 핸들러를 단순하게 유지하고 플러그 처리는 메인 프로그램의 주기적 검사 루프에서 실행하도록 해라.
2. 핸들러에서 signal-safe한 함수만 호출해라.
	- 시그널-세이프 함수의 특성: 재진입 가능, 인터럽트 되지 않는 설계
	- 이를 위한 Sio(Safe I/O) 패키지가 제공됨
3. errno를 저장 및 복원해라 (리눅스 함수들은 에러 상황에서 errno를 설정한다고 한다. 그런데 errno가 뭔데??)
4. 공유 자료 접근 시 모든 시그널을 임시적으로 차단해라.
5. 전역 변수를 volatile로 선언하라. (여기서 핸들러는 무조건 메모리 값만 수정이 가능하다고 들었던 것 같은데 과연 사실일까??)
6. 플래그 선언 시 sig_atomic_t를 사용해라
	- 읽기/쓰기 연산이 단일 명령어로 수행되어서 인터럽트 되지 않는다.
	- 즉, 기계 수준으로 분해했을 때 단일 명령어로만 구성되는 명령어만 가능한 듯 하다. (맞겠지??)

###### 올바른 시그널 처리 예시
내용은 네이버 블로그 포스트로 대체합니다.
[네이버 블로그](https://blog.naver.com/pmdrdocg/224046552837)

###### 이식 가능한 시그널 핸들링
다른 시스템으로 이식 시 발생할 수 있는 문제들
1. 오래된 유닉스에서는 signal()의 의미가 다르다. (아마도 핸들러를 완전히 연결하는 방식이 아니라 그 핸들러를 한번만 사용하고 다시 디폴트로 돌아가는 느낌인듯??)
2. 시스템의 종류에 따라 시스템 콜이 중단되었을 때 대처 방법이 다르다.
	- read, wait, accept와 같은 slow system call이 시그널을 받으면 중단될 수 있다.
	- 이때 일부 시스템은 이를 자동 재시작하지만 나머지 경우에는 프로그래머가 직접 errno를 이용해서 system call을 재시도 해야한다.
	- POSIX에서는 이런 문제를 방지하기 위해서, 또 시그널의 동작을 지정하는 sigaction() 함수가 구조체 설정이 복잡하기 때문에 자동 재시작을 포함하는 래퍼 함수를 정의하기도 한다. (재시작이라는 것의 의미가 정확히 뭔지 모르겠다?? 감은 오는데 정확한지 모르겠으)

#### 06-Synchronizing Flows to Avoid Nasty Concurrency Bugs
###### 등장 배경
동시에 같은 메모리를 읽고 쓰는 여러 흐름들을 안전하게 프로그래밍 하는 것은 컴퓨터 과학에서 가장 어려운 문제 중 하나이다. 따라서 우리는 최대한 많은 상호교차를 허용하면서 정상적인 결과를 보장하도록 흐름들을 동기화해야하는 과제를 갖고 있다.
###### 간단한 동기화 예시
coming soon..

#### 07-Explicitly Waiting for Signals
coming soon..

