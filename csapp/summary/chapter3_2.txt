3.2.1 Machine-Level Code

1. Definition of Machine-Level Programs
- The ISA (Instruction Set Architecture) defines a machine-level program:
  • Instruction set: what operations can be performed  
  • Instruction format: how instructions are represented  
  • State: how executing an instruction affects CPU state (registers, memory, etc.)  
- Although real CPUs use complex optimizations like parallel execution and pipelining,
  the ISA abstracts execution as if instructions run sequentially, one at a time.

2. CPU State Components During Program Execution
- Program Counter (PC, %rip in x86-64)  
  • Holds the address of the next instruction to execute.  
- Integer Registers  
  • x86-64 has 16 general-purpose 64-bit registers.  
  • Used for data storage, pointer management, function arguments/returns, and temporary values.  
- Condition Code Registers  
  • Store results of recent arithmetic/logic operations.  
  • Used to control branching (if, while, etc.).  
- Vector Registers  
  • Support floating-point and SIMD operations.  
  • Can store multiple integers or floating-point values in a single register.

3. Differences Between C Code and Machine Code
- C language provides data types and an abstract memory model.  
- Machine code views memory simply as a byte array.  
- Arrays, structs, and pointers are just memory addresses and byte sequences.

------------------------------------------------------------

3.2.2 Code Examples

1. C Code and Function Structure
Example C code:
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
- multstore calls mult2 to compute a result, then stores that result at the memory location pointed to by dest.  
- The example illustrates a typical flow: "function call → return result → store in memory."

2. Assembly Code Translation
Compilation command:
gcc -Og -S mstore.c
→ Produces mstore.s (human-readable assembly code)

Generated assembly:
multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    call    mult2
    movq    %rax, (%rbx)
    popq    %rbx
    ret
- Built from basic instructions: register save/restore (push/pop), data movement (mov), function call (call), and return (ret).  
- One line of C code expands into a sequence of low-level operations.

3. Object Code and Machine Code
Compilation command:
gcc -Og -c mstore.c
→ Produces mstore.o (object code made of machine byte sequences)

Example bytes:
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
- Each byte encodes an assembly instruction.  
- Humans cannot easily read this, but the CPU executes it directly.

4. Disassembly
Command:
objdump -d mstore.o
→ Converts object code back into assembly.

Example output:
0000000000000000 <multstore>:
   0:  53                  push   %rbx
   1:  48 89 d3            mov    %rdx,%rbx
   4:  e8 00 00 00 00      callq  9 <multstore+0x9>
   9:  48 89 03            mov    %rax,(%rbx)
   c:  5b                  pop    %rbx
   d:  c3                  retq
- Byte-encoded instructions are restored to human-readable form.  
- x86-64 instructions are variable-length (1–15 bytes), so decoding rules are important.

5. Executable Files and Linking
main.c example:
#include <stdio.h>
void multstore(long, long, long *);
int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}

mult2.c example:
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
Compilation and linking:
gcc -Og -o prog main.c mstore.c mult2.c
→ Produces executable file prog

- The linker combines multiple object files (main.o, mstore.o, mult2.o).  
- It replaces function call placeholders with real addresses.  
- It also includes standard library functions (e.g., printf).  
- The result is a standalone executable program.

6. Overall Meaning of the Process
- This section illustrates how abstract C code becomes executable machine code.  
- The full transformation pipeline:
  (1) Write C code  
  (2) Translate to assembly code  
  (3) Generate object code (byte sequence)  
  (4) Linker builds executable file  
  (5) Disassembler can analyze code back into assembly  
- Helps understand the relationship between abstraction layers and actual hardware execution.
