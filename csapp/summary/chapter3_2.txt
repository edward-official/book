3.2.1 Machine-Level Code

1. 기계어 수준 프로그램의 정의
- ISA(Instruction Set Architecture)가 기계어 프로그램을 정의:
  • 명령어 집합: 어떤 연산을 할 수 있는지
  • 명령어 형식: 명령어가 어떻게 표현되는지
  • 상태(state): 명령어 실행이 CPU 상태(레지스터, 메모리 등)에 미치는 영향
- 실제 CPU는 병렬 실행, 파이프라인 등 복잡한 최적화를 하지만,
  ISA 관점에서는 한 번에 한 명령어씩 순차 실행하는 것으로 추상화됨.

2. 프로그램 실행 시 CPU 상태 요소
- 프로그램 카운터 (Program Counter, PC, %rip in x86-64)
  • 다음 실행할 명령어의 메모리 주소를 가리킴.
- 정수 레지스터 (Integer Registers)
  • x86-64에는 16개의 64비트 레지스터 존재.
  • 데이터 저장, 포인터 관리, 함수 인자 및 반환값, 임시 값 보관에 사용.
- 조건 코드 레지스터 (Condition Codes)
  • 최근 산술/논리 연산 결과 기록.
  • 분기문(if, while 등) 제어 흐름에 활용.
- 벡터 레지스터 (Vector Registers)
  • 부동소수점 및 SIMD 연산 지원.
  • 하나의 레지스터에 여러 개의 정수/부동소수점 값을 저장 가능.

3. C 코드와 기계어 코드의 차이
- C 언어: 데이터 타입, 추상적 메모리 모델 제공.
- 기계어: 메모리를 단순한 바이트 배열로 취급.
- 배열, 구조체, 포인터는 단순히 메모리 주소와 바이트 집합으로 표현됨.




3.2.2 Code Examples

1. C 코드와 함수 구조
예제로 제시된 C 코드:
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
- multstore는 mult2 함수를 호출해 결과를 계산하고, 그 값을 dest가 가리키는 메모리에 저장한다.
- 예제는 "함수 호출 → 결과 반환 → 메모리 저장"이라는 전형적인 흐름을 보여준다.

2. 어셈블리 코드 변환
컴파일 명령:
gcc -Og -S mstore.c
→ mstore.s 생성 (사람이 읽을 수 있는 어셈블리 코드)

생성된 어셈블리 코드:
multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    call    mult2
    movq    %rax, (%rbx)
    popq    %rbx
    ret
- 레지스터 저장(push/pop), 데이터 이동(mov), 함수 호출(call), 반환(ret) 같은 기본 명령어들로 구성된다.
- C 언어의 추상적인 한 줄이 저수준 동작의 집합으로 바뀌는 것을 확인할 수 있다.

3. 목적 코드와 기계어
컴파일 명령:
gcc -Og -c mstore.c
→ mstore.o 생성 (기계어 바이트 시퀀스로 구성된 목적 코드)

예: 
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
- 각 바이트가 어셈블리 명령어를 인코딩한 것.
- 사람은 직접 읽기 어렵고, CPU만이 직접 실행할 수 있다.

4. 디스어셈블러를 통한 해석
objdump -d mstore.o
→ 목적 코드를 다시 어셈블리 코드 형태로 변환해 보여줌.

출력 예시:
0000000000000000 <multstore>:
   0:  53                  push   %rbx
   1:  48 89 d3            mov    %rdx,%rbx
   4:  e8 00 00 00 00      callq  9 <multstore+0x9>
   9:  48 89 03            mov    %rax,(%rbx)
   c:  5b                  pop    %rbx
   d:  c3                  retq
- 바이트 단위로 저장된 코드가 다시 사람이 읽을 수 있는 명령어로 복원된다.
- x86-64 명령어는 길이가 가변적(1~15바이트)이므로 해석 규칙이 중요하다.

5. 실행 파일과 링킹
main.c 예시:
#include <stdio.h>
void multstore(long, long, long *);
int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}

mult2.c 예시:
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
컴파일 및 링크:
gcc -Og -o prog main.c mstore.c mult2.c
→ 실행 파일 prog 생성

- 링커는 여러 목적 코드 파일(main.o, mstore.o, mult2.o)을 결합한다.
- 함수 호출 주소를 실제 실행 가능한 주소로 교체한다.
- 표준 라이브러리 함수(printf 등)도 포함한다.
- 최종적으로 독립 실행 가능한 프로그램을 만든다.

6. 전체 과정의 의미
- 이 절은 "추상적 C 코드가 어떻게 하드웨어에서 실행 가능한 기계어가 되는가"를 보여주는 교육적 예시다.
- 전체 변환 과정:
  (1) C 코드 작성
  (2) 어셈블리 코드로 변환
  (3) 목적 코드(바이트 시퀀스) 생성
  (4) 링커가 실행 파일 완성
  (5) 디스어셈블러로 분석 가능
- 추상화 계층과 하드웨어 실행 사이의 관계를 구체적으로 이해할 수 있다.

